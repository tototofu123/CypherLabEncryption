import { CipherMethod } from './types';

export const METHODS: CipherMethod[] = [
  // --- ANCIENT ---
  {
    id: 'scytale',
    name: 'Scytale',
    description: 'Transposition: A strip of parchment is wrapped around a rod. The message is written across; when unwrapped, letters are scrambled.',
    longDescription: 'The Scytale (rhymes with "Italy") is one of the earliest cryptographic devices, used prominently by the Spartans in ancient Greece around 400 BC. It is a transposition cipher, meaning it rearranges the letters of a message rather than substituting them. \n\nThe system consisted of a cylinder (the scytale) and a strip of parchment or leather. The sender would wrap the strip spirally around the rod and write the message lengthwise along the rod. When the strip was unwrapped, the letters would appear as a jumbled scramble. The receiver, possessing a rod of the exact same diameter, would wrap the strip around their rod to realign the letters and read the message. \n\nWhile effective against illiterate enemies or casual interception, the security relies entirely on the secrecy of the rod\'s diameter. If an enemy intercepted the strip, they could easily break the code by trying rods of different sizes until words appeared. Today, the Scytale is a classic example of how physical hardware was used to enforce cryptographic logic before mathematics took over.',
    era: 'Ancient (Sparta)',
    category: 'Ancient',
    securityScore: 10,
    icon: 'edit_note',
    colorClass: 'text-amber-600',
    tags: ['Transposition', 'Physical'],
    vulnerability: 'Very Low: Easily broken if the attacker finds a rod of the right size or tries different diameters.',
    vulnerabilityIcon: 'broken_image',
    route: '/simulator/scytale',
    algoType: 'substitution' // Using substitution logic handler for simplicity in UI, though technically transposition
  },
  {
    id: 'atbash',
    name: 'Atbash Cipher',
    description: 'Substitution: A simple monoalphabetic substitution where the alphabet is reversed (A becomes Z, B becomes Y).',
    longDescription: 'The Atbash cipher is a specific type of monoalphabetic substitution cipher originally used to encrypt the Hebrew alphabet. It is one of the oldest known ciphers, appearing in the Bible (Book of Jeremiah). The principle is extremely simple: the alphabet is mapped to its reverse. The first letter becomes the last, the second becomes the second-to-last, and so on. \n\nIn English, A is replaced by Z, B by Y, C by X, and so forth. Because the relationship is symmetric, the encryption and decryption processes are identical. If you apply Atbash to a message twice, you get the original text back. \n\nWhile culturally significant, Atbash offers virtually no security. There is no "key" to change; the method itself is the key. Once an adversary knows you are using Atbash, they can instantly read the message. It serves as a prime example of "security by obscurity," which is widely rejected in modern cryptography.',
    era: 'Ancient (Hebrew)',
    category: 'Ancient',
    securityScore: 2,
    icon: 'swap_horiz',
    colorClass: 'text-stone-400',
    tags: ['Substitution', 'Biblical'],
    vulnerability: 'None: Since the "key" is always the same, it offers no actual security against anyone who knows the method.',
    vulnerabilityIcon: 'lock_open',
    route: '/simulator/atbash',
    algoType: 'substitution'
  },
  {
    id: 'caesar',
    name: 'Caesar Cipher',
    description: 'Substitution: Shifts every letter in the plaintext by a fixed number of positions down the alphabet.',
    longDescription: 'The Caesar Cipher is one of the simplest and most widely known encryption techniques in history. Named after Julius Caesar, who used it in his private correspondence (specifically utilizing a shift of 3), it is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on. \n\nMathematically, the encryption can be represented using modular arithmetic by first transforming the letters into numbers, according to the scheme, A = 0, B = 1, ..., Z = 25. Encryption of a letter x by a shift n can be described mathematically as E_n(x) = (x + n) mod 26. Despite its historical significance, the Caesar cipher offers essentially no security by modern standards. \n\nBecause the underlying distribution of letter frequencies in the alphabet remains unchanged (e.g., "E" is still the most common letter, just mapped to a different symbol), it is trivially breakable using frequency analysis. Furthermore, with only 25 possible keys (shifts), an attacker can easily use a "brute force" attack to test every possibility until the output makes sense.',
    era: 'Ancient (100 BC)',
    category: 'Ancient',
    securityScore: 5,
    icon: 'history_edu',
    colorClass: 'text-red-400',
    tags: ['Substitution'],
    vulnerability: 'Easily broken by frequency analysis or brute force (only 25 possibilities).',
    vulnerabilityIcon: 'warning',
    route: '/simulator/caesar',
    algoType: 'substitution'
  },
  {
    id: 'polybius',
    name: 'Polybius Square',
    description: 'Fractionation: Each letter is represented by its coordinates in a 5×5 grid. Turns letters into numbers.',
    longDescription: 'The Polybius Square, invented by the ancient Greek historian and scholar Polybius, is a device for fractionating plaintext characters so that they can be represented by a smaller set of symbols. It typically uses a 5x5 grid filled with the letters of the alphabet (combining I and J to fit 26 letters into 25 spots). \n\nEach letter is replaced by its coordinates in the grid. For example, if "B" is in the first row and second column, it becomes "12". This converts a stream of letters into a stream of numbers. This was particularly useful for telegraphy or signaling with torches, where representing 26 distinct states was difficult, but representing 5 states (1-5) was easy. \n\nWhile it is technically a substitution cipher, the Polybius Square is important because it reduces the complexity of transmission characters. However, like other monoalphabetic substitutions, it retains the frequency characteristics of the original language and is easily broken by analysis. It famously laid the groundwork for the Playfair cipher and the ADFGVX cipher used in WWI.',
    era: 'Ancient (Greece)',
    category: 'Ancient',
    securityScore: 8,
    icon: 'grid_4x4',
    colorClass: 'text-orange-300',
    tags: ['Fractionation'],
    vulnerability: 'Low: Vulnerable to frequency analysis, though it was the basis for more complex later systems.',
    vulnerabilityIcon: 'query_stats',
    route: '/simulator/polybius',
    algoType: 'substitution'
  },
  {
    id: 'vigenere',
    name: 'Vigenère Cipher',
    description: 'Polyalphabetic: Uses a keyword to shift letters by different amounts, making simple frequency analysis harder.',
    longDescription: 'The Vigenère Cipher is a method of encrypting alphabetic text by using a series of interwoven Caesar ciphers, based on the letters of a keyword. It employs a form of polyalphabetic substitution. First described by Giovan Battista Bellaso in 1553, the cipher is easy to understand and implement, but it resisted all attempts to break it for three centuries, earning it the title "le chiffre indéchiffrable". \n\nIn a Vigenère cipher, the alphabet is written out 26 times in different rows, each alphabet shifted cyclically to the left compared to the previous row. The alphabet used at each point depends on a repeating keyword. This smooths out the frequency distribution of the letters, making simple frequency analysis ineffective. However, the Vigenère cipher was eventually broken in the 19th century by Friedrich Kasiski and Charles Babbage. They realized that repeating patterns in the ciphertext could reveal the length of the keyword, allowing the text to be treated as multiple interleaved Caesar ciphers.',
    era: 'Renaissance (1553)',
    category: 'Ancient',
    securityScore: 15,
    icon: 'password',
    colorClass: 'text-red-300',
    tags: ['Polyalphabetic'],
    vulnerability: 'Broken in the 19th century using mathematical patterns (Kasiski examination).',
    vulnerabilityIcon: 'search_off',
    route: '/simulator/vigenere',
    algoType: 'polyalphabetic'
  },

  // --- 20TH CENTURY ---
  {
    id: 'playfair',
    name: 'Playfair Cipher',
    description: 'Bigram Substitution: Encrypts pairs of letters (digrams) instead of single letters using a 5×5 key square.',
    longDescription: 'The Playfair cipher was the first practical diagram substitution cipher. Invented by Charles Wheatstone in 1854 (but named after Lord Playfair who promoted its use), it encrypts pairs of letters (digraphs) rather than single letters. \n\nA 5x5 grid of letters is constructed using a keyword (dropping duplicates and combining I/J). To encrypt, the message is broken into pairs. If a pair contains the same letter (e.g., "EE"), a filler "X" is inserted. The rules for encryption depend on the position of the two letters in the grid: if in the same row, shift right; if in the same column, shift down; if in a rectangle, swap corners. \n\nBy encrypting pairs, the Playfair cipher destroys simple single-letter frequency statistics. There are 600 possible pairs instead of 26 letters, making frequency analysis much harder. It was used by the British in the Boer War and WWI, and by the Australians in WWII. However, with enough text, it is breakable by analyzing digraph frequencies.',
    era: '20th Century (WWI)',
    category: '20th Century',
    securityScore: 25,
    icon: 'grid_on',
    colorClass: 'text-yellow-600',
    tags: ['Digraph Substitution'],
    vulnerability: 'Low/Medium: Much harder to break than Caesar, but vulnerable to computers and large amounts of text.',
    vulnerabilityIcon: 'fact_check',
    route: '/simulator/playfair',
    algoType: 'block'
  },
  {
    id: 'enigma',
    name: 'Enigma Machine',
    description: 'Electromechanical: Uses rotating rotors and a plugboard to create a complex, ever-changing substitution cipher.',
    longDescription: 'The Enigma machine is a cipher device developed and used in the early- to mid-20th century to protect commercial, diplomatic, and military communication. It was employed extensively by Nazi Germany during World War II. The machine features a keyboard, a lamp board, and a set of electromechanical rotors. \n\nWhen a key is pressed, an electric signal passes through a plugboard, then through three or four rotating rotors, hits a reflector, and finally lights up a letter on the lamp board. Crucially, the rotors step with every key press. This created a polyalphabetic substitution with a period so long it was effectively random. \n\nDespite its complexity, the Enigma had a fatal flaw: the reflector meant no letter could ever map to itself. This mathematical certainty, combined with procedural errors by German operators, allowed Allied cryptologists—led by Alan Turing at Bletchley Park—to break the code.',
    era: 'WWII (1939)',
    category: '20th Century',
    securityScore: 40,
    icon: 'settings_suggest',
    colorClass: 'text-amber-400',
    tags: ['Electro-mechanical'],
    vulnerability: 'Historical: Very high for its time; eventually broken by Alan Turing and the team at Bletchley Park.',
    vulnerabilityIcon: 'no_encryption',
    route: '/education/enigma',
    algoType: 'machine'
  },
  {
    id: 'otp',
    name: 'One-Time Pad',
    description: 'Perfect Secrecy: Uses a truly random key that is as long as the message itself. Used once and destroyed.',
    longDescription: 'The One-Time Pad (OTP) is the only encryption method mathematically proven to be unbreakable. Developed in 1917, it pairs the plaintext with a random secret key (also referred to as a one-time pad) of the same length. \n\nEach bit or character of the plaintext is combined (usually via XOR or modular addition) with the corresponding character from the pad. Because the key is truly random, the resulting ciphertext appears completely random. Even with infinite computing power, an attacker cannot break it because every possible plaintext of the same length is equally likely to be the decryption result. \n\nHowever, OTP has massive practical drawbacks: the key must be generated truly randomly, must be at least as long as the message, must be securely distributed to the recipient, and must never be reused. These logistical nightmares meant it was primarily used for high-level diplomatic lines, such as the "Red Phone" between Washington and Moscow during the Cold War.',
    era: '20th Century (Cold War)',
    category: '20th Century',
    securityScore: 100,
    icon: 'lock_reset',
    colorClass: 'text-pink-500',
    tags: ['Perfect Secrecy', 'Theoretical'],
    vulnerability: 'Unbreakable: Mathematically proven to be impossible to crack if the key is truly random and kept secret.',
    vulnerabilityIcon: 'shield',
    route: '/simulator/otp',
    algoType: 'polyalphabetic'
  },
  {
    id: 'des',
    name: 'DES',
    description: 'Symmetric Block Cipher: Uses a 56-bit key to scramble data in blocks. Was the first "modern" standard.',
    longDescription: 'The Data Encryption Standard (DES) is a symmetric-key algorithm for the encryption of digital data. Developed in the early 1970s at IBM, it uses a 56-bit key (with 8 bits used for parity checking). The algorithm transforms the input in a series of 16 "rounds" of substitution and permutation (Feistel network). \n\nBy the late 1990s, the 56-bit key was definitively proven to be too short. In 1998, the EFF built "Deep Crack," a specialized machine which broke a DES key in 56 hours. This demonstrated that a determined adversary could decrypt DES traffic, rendering it obsolete. It was superseded by Triple DES (3DES) and eventually AES.',
    era: '1970s',
    category: '20th Century',
    securityScore: 25,
    icon: 'storage',
    colorClass: 'text-orange-400',
    tags: ['Block Cipher'],
    vulnerability: 'Obsolete: Can be cracked in hours by modern computers via brute force.',
    vulnerabilityIcon: 'timer',
    route: '/simulator/des',
    algoType: 'block'
  },
  {
    id: 'rc4',
    name: 'RC4',
    description: 'Stream Cipher: Generates a pseudorandom stream of bits and XORs them with the message. Extremely fast.',
    longDescription: 'RC4 (Rivest Cipher 4) is a stream cipher designed by Ron Rivest in 1987. It is remarkable for its simplicity and speed in software. It works by generating a pseudorandom stream of bits (a keystream) which is then combined with the plaintext using bitwise XOR. \n\nFor decades, RC4 was the most widely used stream cipher in the world, securing protocols like WEP and WPA for Wi-Fi and SSL/TLS for secure websites. However, over time, significant biases were discovered in its keystream generation. These biases allow attackers to recover the plaintext or the key by analyzing a large volume of encrypted traffic. \n\nBecause of these vulnerabilities, RC4 is now prohibited in modern implementations of TLS (RFC 7465). While it was a workhorse of the early internet, it serves as a lesson that cryptographic algorithms must undergo constant scrutiny as statistical attack methods improve.',
    era: '20th Century (1987)',
    category: '20th Century',
    securityScore: 20,
    icon: 'stream',
    colorClass: 'text-purple-400',
    tags: ['Stream Cipher'],
    vulnerability: 'Broken: Multiple vulnerabilities discovered over time; it is now prohibited in modern web protocols (TLS).',
    vulnerabilityIcon: 'running_with_errors',
    route: '/simulator/rc4',
    algoType: 'polyalphabetic' // Sim behaves like polyalphabetic stream
  },
  {
    id: 'md5-sha1',
    name: 'MD5 / SHA-1',
    description: 'Hashing: Turns any input into a fixed-length "fingerprint." Unlike ciphers, it cannot be "decrypted".',
    longDescription: 'MD5 and SHA-1 are widely used cryptographic hash functions that process input data to produce a fixed-size hash value. Hash functions are fundamental to digital security, used to verify file integrity and store passwords. \n\nHowever, both algorithms are now considered broken due to collision vulnerabilities. A "collision" occurs when two distinct inputs produce the exact same hash output. If an attacker can manufacture a collision, they can swap a legitimate file with a malicious one without changing the digital fingerprint. MD5 and SHA-1 have been replaced by the SHA-2 and SHA-3 families.',
    era: '1990s',
    category: '20th Century',
    securityScore: 30,
    icon: 'fingerprint',
    colorClass: 'text-yellow-400',
    tags: ['Hash'],
    vulnerability: 'Insecure: Vulnerable to "collision attacks" where two different passwords produce the same hash.',
    vulnerabilityIcon: 'content_copy',
    route: '/simulator/md5-sha1',
    algoType: 'hash'
  },

  // --- MODERN ---
  {
    id: 'aes',
    name: 'AES',
    description: 'Symmetric Block Cipher: Uses complex mathematical rounds with keys up to 256 bits. Global standard.',
    longDescription: 'The Advanced Encryption Standard (AES) is a specification for the encryption of electronic data established by NIST in 2001. It is a symmetric-key block cipher that can use keys of 128, 192, and 256 bits. \n\nUnlike DES, AES uses a substitution-permutation network. It is fast in both software and hardware and requires little memory. The algorithm operates on a 4x4 array of bytes, termed the state. It runs through multiple rounds of SubBytes, ShiftRows, MixColumns, and AddRoundKey. To date, there are no known practical attacks that can break AES when correctly implemented. It is used to secure everything from your WiFi to top-secret government documents.',
    era: 'Modern (2001)',
    category: 'Modern',
    securityScore: 98,
    icon: 'shield_lock',
    colorClass: 'text-emerald-400',
    tags: ['Standard'],
    vulnerability: 'Military Grade: The current global standard. It would take billions of years to crack with current tech.',
    vulnerabilityIcon: 'verified_user',
    route: '/simulator/aes',
    algoType: 'block'
  },
  {
    id: 'rsa',
    name: 'RSA',
    description: 'Asymmetric: Based on the difficulty of factoring the product of two massive prime numbers. Used for key exchange.',
    longDescription: 'RSA (Rivest–Shamir–Adleman) is one of the first public-key cryptosystems and is widely used for secure data transmission. In a public-key system, the encryption key is public and distinct from the decryption key, which is kept secret (private). In RSA, this asymmetry is based on the practical difficulty of factoring the product of two large prime numbers, the "factoring problem". \n\nA user of RSA creates and publishes a public key based on two large prime numbers, along with an auxiliary value. The prime numbers are kept secret. Messages can be encrypted by anyone, via the public key, but can only be decoded by someone who knows the prime numbers. \n\nRSA is relatively slow, so it is rarely used to encrypt user data directly. Instead, it is used to securely exchange a symmetric key (like an AES key) which is then used for the bulk encryption. This hybrid approach underpins the security of the web (HTTPS).',
    era: 'Modern (Asymmetric)',
    category: 'Modern',
    securityScore: 90,
    icon: 'key',
    colorClass: 'text-blue-500',
    tags: ['Asymmetric', 'Public Key'],
    vulnerability: 'High: Very secure for key exchange, though it requires larger keys (e.g., 2048-bit) to stay ahead of computing power.',
    vulnerabilityIcon: 'vpn_key',
    route: '/simulator/rsa',
    algoType: 'block'
  },
  {
    id: 'ecc',
    name: 'ECC (Elliptic Curve)',
    description: 'Algebraic Curves: Uses the math of elliptic curves. Same security as RSA but with much smaller keys.',
    longDescription: 'Elliptic-curve cryptography (ECC) is an approach to public-key cryptography based on the algebraic structure of elliptic curves over finite fields. ECC allows smaller keys compared to non-EC cryptography (based on plain Galois fields) to provide equivalent security. \n\nElliptic curves are applicable for key agreement, digital signatures, pseudo-random generators and other tasks. Indirectly, they can be used for encryption by combining the key agreement with a symmetric encryption scheme. \n\nFor example, a 256-bit elliptic curve public key should provide comparable security to a 3072-bit RSA public key. This efficiency is crucial for mobile devices and blockchain technologies. Bitcoin and Ethereum use the secp256k1 curve to secure user funds. It is currently considered the gold standard for efficient public-key crypto.',
    era: 'Modern (Blockchain)',
    category: 'Modern',
    securityScore: 99,
    icon: 'timeline',
    colorClass: 'text-teal-400',
    tags: ['Asymmetric', 'Blockchain'],
    vulnerability: 'Maximum: This is what secures Bitcoin and Ethereum. Efficient and highly resistant to attacks.',
    vulnerabilityIcon: 'verified',
    route: '/simulator/ecc',
    algoType: 'block'
  },
  {
    id: 'chacha20',
    name: 'ChaCha20',
    description: 'Stream Cipher: A modern, high-speed alternative to AES. Designed for devices without dedicated crypto hardware.',
    longDescription: 'ChaCha20 is a stream cipher developed by Daniel J. Bernstein in 2008. It is a modification of Salsa20 and is designed to provide high performance in software implementations, whereas AES is often optimized for hardware. \n\nChaCha20 uses a 256-bit key, a 32-bit nonce, and a 32-bit counter to generate a keystream which is XORed with the plaintext. Its internal operation involves a "quarter-round" function that mixes the state using addition, XOR, and rotation operations. \n\nBecause it relies on simple CPU operations (add, rotate, xor), it is immune to "timing attacks" that can plague AES implementations in software. Google adopted ChaCha20 (along with the Poly1305 authenticator) for TLS traffic on mobile devices to ensure fast, secure browsing on cheaper phones that lack AES acceleration chips. It is now a widely adopted IETF standard.',
    era: 'Modern (Google)',
    category: 'Modern',
    securityScore: 98,
    icon: 'speed',
    colorClass: 'text-cyan-400',
    tags: ['Stream Cipher', 'Mobile'],
    vulnerability: 'Military Grade: Highly secure and increasingly used as a standard in modern VPNs and mobile web traffic.',
    vulnerabilityIcon: 'bolt',
    route: '/simulator/chacha20',
    algoType: 'polyalphabetic'
  },
  {
    id: 'sha256',
    name: 'SHA-256',
    description: 'Cryptographic Hash: A "one-way" function. Bitcoin uses this for mining and securing addresses.',
    longDescription: 'SHA-256 is part of the SHA-2 family designed by the NSA. It generates a unique 256-bit signature for a text or data file. \n\nOne of the most famous applications of SHA-256 is in the Bitcoin blockchain. Bitcoin uses SHA-256 in its Proof of Work algorithm. The security of SHA-256 relies on collision resistance and preimage resistance. While theoretical attacks exist for reduced-round versions, the full SHA-256 algorithm remains unbroken.',
    era: 'Modern (Bitcoin)',
    category: 'Modern',
    securityScore: 95,
    icon: 'currency_bitcoin',
    colorClass: 'text-primary',
    tags: ['Blockchain'],
    vulnerability: 'High: Extremely resistant to collisions and preimage attacks.',
    vulnerabilityIcon: 'check_circle',
    route: '/simulator/sha256',
    algoType: 'hash'
  },
  {
    id: 'argon2',
    name: 'Argon2 / BCrypt',
    description: 'Key Derivation: Specifically designed for passwords. It is "slow" by design to prevent GPU/ASIC brute-forcing.',
    longDescription: 'Argon2 is a key derivation function that was selected as the winner of the Password Hashing Competition in 2015. It is designed to resist GPU and ASIC-based password cracking attacks. \n\nStandard hash functions are designed to be fast, which is a liability for passwords. Argon2 is designed to be "memory-hard," meaning it requires a significant amount of RAM to compute. This makes it incredibly expensive to build custom hardware to crack passwords in bulk.',
    era: 'Modern (Passwords)',
    category: 'Modern',
    securityScore: 99,
    icon: 'memory',
    colorClass: 'text-primary',
    tags: ['Password Storage'],
    vulnerability: 'Maximum: The current gold standard for storing user passwords in web apps.',
    vulnerabilityIcon: 'lock_person',
    route: '/simulator/argon2',
    algoType: 'kdf'
  }
];

export const PROFILE_IMG = "https://lh3.googleusercontent.com/aida-public/AB6AXuDpN4e_-rLlQi1bJqovq_85uwyxGWGkALq6c96L_dBZ7x6HtMPbqoZ0TZMNoZoAjILuqqhT4QUtAcingdS2xCIpFn6lsijNO2t1GdtJ9OwtSJLXXpt3lOSbfiaL4DZCXti9uKMdsTn-cWJUfcrhKalL5nVY3FsmZNH0P7pxUv4vPo2rePDBEnvf39M63g_6GV7Zfi9V1psXgIugDXS0A_pvD1t4ryzMAiBVvN8IR_gEPVTu9gdCMk4dH-VYdZ8njeHGqIIKujeGGg";
export const BLETCHLEY_IMG = "https://lh3.googleusercontent.com/aida-public/AB6AXuA28QK5RAMoLhW21Q0fsrmLhqWINCyB1hzDH5vlIn5xDke7sHpw58K8NvHzvJo4UfD60fCBc2VWsNfjiQ3DaiOR7vjkgXnyYOUw5Tup-RSdhneTPtDxcK2qesAxr6a9-BhnjWkDMFzV__Cd6uP1cF43I8ojRevXMrBB4EP4R3mnZV06zpd5dMwngUKiMTahawOYlXbjRrxyCp-5_w96QHN2zXNlv5ZHeBvVt8hqoRqkVJ91f49z0XHHA-NnB6hkNcQ82pg3sfJXxg";
